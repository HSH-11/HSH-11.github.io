---
layout: post
title: LG ìœ í”ŒëŸ¬ìŠ¤ ìœ ë ˆì¹´ ì¢…í•©í”„ë¡œì íŠ¸
description: í†µì‹ ì„±í–¥ íŒŒì•… ë° ìš”ê¸ˆì œ ë¹„êµÂ·ì¶”ì²œ ì„œë¹„ìŠ¤
image: '/images/2025-09-28-ìœ ë ˆì¹´ ì¢…í•©í”„ë¡œì íŠ¸/title-1759057651864-3.png'
video_embed: https://www.youtube.com/embed/d-A9WSjrnzs
tags: [Project]
tags_color: '#de47e2'
featured: true
toc: true
---

### í”„ë¡œì íŠ¸ ì†Œê°œ

ìì—°ì–´ ëŒ€í™”ë¥¼ í†µí•´ ì‚¬ìš©ìì˜ í†µì‹  ì„±í–¥ì„ ë¶„ì„í•˜ê³ , ìµœì ì˜ ìš”ê¸ˆì œë¥¼ ì¶”ì²œí•˜ëŠ” ì§€ëŠ¥í˜• ì„œë¹„ìŠ¤

ğŸ—£ï¸ **ìì—°ì–´ ìƒë‹´**ì„ í†µí•œ ë§ì¶¤í˜• ìš”ê¸ˆì œ ì¶”ì²œ

ğŸ›¡ï¸ **ê¸ˆì¹™ì–´ ê´€ë¦¬, ì‚¬ìš©ì ë¶„ì„** ë° ê´€ë¦¬ì ë°±ì˜¤í”¼ìŠ¤ë¥¼ í†µí•œ ì„œë¹„ìŠ¤ í’ˆì§ˆ í–¥ìƒ

ğŸ§  **ëŒ€í™” í† í”½ ë¶„ë¥˜**ë¥¼ í†µí•œ ì§ˆë¬¸ ë¬¸ë§¥ ê¸°ë°˜ ëŒ€í™” ê°€ëŠ¥

ğŸ—‚ï¸ **Redis ì™€ MongoDB**ë¥¼ í™œìš©í•œ ëŒ€í™” ë‚´ì—­ ì €ì¥ ë° ë¶„ì„

ğŸ“Š **Elsaticsearch + Kibana** ì—°ë™ìœ¼ë¡œ ì‚¬ìš©ì í–‰ë™ ë¡œê·¸ ì‹œê°í™” ë° ë¶„ì„

------

### ì£¼ìš” ê¸°ëŠ¥

1. **íšŒì›ê°€ì… / ë¡œê·¸ì¸**: JWT ê¸°ë°˜ì˜ RTR(Refresh Token Rotation) ë°©ì‹ì„ ì ìš©í•´ ë³´ì•ˆì„±ì„ ê°•í™”í–ˆê³ , Spring Securityì™€ ì—°ë™í•˜ì—¬ ì ‘ê·¼ ì œì–´ ê´€ë¦¬

2. **ë³´ì•ˆ**: ì—­í• (Role) ê¸°ë°˜ ì ‘ê·¼ ì œí•œì„ ì ìš©í•˜ì—¬ ì‚¬ìš©ìì˜ ê¶Œí•œì— ë”°ë¼ ì ‘ê·¼ ê°€ëŠ¥í•œ ë¦¬ì†ŒìŠ¤ë¥¼ êµ¬ë¶„

3. **ë§ˆì´í˜ì´ì§€**: ì‚¬ìš©ìê°€ ìì‹ ì´ ê°€ì…í•œ ìš”ê¸ˆì œ, ë°ì´í„° ì‚¬ìš©ëŸ‰, ê°œì¸ ì •ë³´ë¥¼ ì§ê´€ì ìœ¼ë¡œ ì¡°íšŒí•  ìˆ˜ ìˆë„ë¡ êµ¬í˜„

4. **ìš”ê¸ˆì œ ê²€ìƒ‰ ë° ë¹„êµ**: ë‹¤ì–‘í•œ ìš”ê¸ˆì œë¥¼ íƒìƒ‰í•  ìˆ˜ ìˆëŠ” ëª©ë¡ í˜ì´ì§€ì™€ ìƒì„¸ ì¡°íšŒ í˜ì´ì§€ë¥¼ ì œê³µí•˜ë©°, ì—¬ëŸ¬ ìš”ê¸ˆì œë¥¼ ë™ì‹œì— AIë¥¼ í†µí•´ ë¹„êµí•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ ì§€ì›

5. **AI ì±—ë´‡ ìƒë‹´** (ë©€í‹°í„´ ì§€ì›): Gemini ê¸°ë°˜ì˜ ìì—°ì–´ ì²˜ë¦¬ ëª¨ë¸ì„ í™œìš©í•´ ë‹¨ìˆœ ì§ˆì˜ì‘ë‹µì„ ë„˜ì–´ **ë©€í‹°í„´ ëŒ€í™”**ë¥¼ ì§€ì›. ì‚¬ìš©ìì˜ ì´ì „ ëŒ€í™” ë§¥ë½ì„ ë°˜ì˜í•´ ë³´ë‹¤ ìì—°ìŠ¤ëŸ½ê³  ì¼ê´€ëœ ìƒë‹´ì´ ê°€ëŠ¥í•˜ë©°, ìš”ê¸ˆì œ ì¶”ì²œê³¼ ë¦¬ë·° ìš”ì•½ì„ í•¨ê»˜ ì œê³µ

6. **ê¸ˆì¹™ì–´ ê´€ë¦¬**: ê´€ë¦¬ì ë°±ì˜¤í”¼ìŠ¤ì—ì„œ ê¸ˆì¹™ì–´ë¥¼ ë“±ë¡Â·ê´€ë¦¬í•  ìˆ˜ ìˆë„ë¡ í•˜ì—¬ ìƒë‹´ í’ˆì§ˆì„ ìœ ì§€

7. **ëŒ€ì‹œë³´ë“œ**: Elasticsearch + Kibana ê¸°ë°˜ ëŒ€ì‹œë³´ë“œë¥¼ ì œê³µí•´ ì±—ë´‡ ëŒ€í™” ë¡œê·¸, ì‚¬ìš©ì ì˜ë„ ë¶„ë¥˜ ê²°ê³¼, ì‘ë‹µ ì‹œê°„ ë“±ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ì‹œê°í™”í•˜ê³ , ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì„œë¹„ìŠ¤ í’ˆì§ˆì„ ëª¨ë‹ˆí„°ë§

8. **ì¶”ì²œ ì§ˆë¬¸ ì œê³µ**: Elasticsearchì— ì„ë² ë”©ëœ ì§ˆë¬¸ ë°ì´í„°ì™€ ì‚¬ìš©ìì˜ ì…ë ¥ì„ ë²¡í„° ìœ ì‚¬ë„ ê¸°ë°˜ìœ¼ë¡œ ë¹„êµí•˜ì—¬, ìƒí™©ì— ë§ëŠ” **ì¶”ì²œ ì§ˆë¬¸**ì„ ì œê³µí•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ì‚¬ìš©ìëŠ” ì¶”ê°€ì ìœ¼ë¡œ ë¬¼ì–´ë³¼ ìˆ˜ ìˆëŠ” ìœ ì‚¬ ì§ˆë¬¸ì„ ë¹ ë¥´ê²Œ í™•ì¸í•  ìˆ˜ ìˆë‹¤
9. **ìŒì„± ê¸°ë°˜ ì§ˆë¬¸ ì…ë ¥(STT)**: ìŒì„± ì¸ì‹(STT)ì„ ì ìš©í•´ ì‚¬ìš©ìê°€ í‚¤ë³´ë“œ ì…ë ¥ ì—†ì´ **ìŒì„±ìœ¼ë¡œ ì§ˆë¬¸ì„ ì „ë‹¬**í•  ìˆ˜ ìˆìœ¼ë©°, ì´ ì—­ì‹œ ë©€í‹°í„´ ë¬¸ë§¥ ì•ˆì—ì„œ ì²˜ë¦¬ëœë‹¤

------

###  ê¸°ìˆ  ìŠ¤íƒ

**Backend**

[![stackticon](https://firebasestorage.googleapis.com/v0/b/stackticon-81399.appspot.com/o/images%2F1759059073351?alt=media&token=22eaaffa-d5d0-4c6b-8768-68ca74d0aea5)](https://github.com/msdio/stackticon)

**Frontend**

[![stackticon](https://firebasestorage.googleapis.com/v0/b/stackticon-81399.appspot.com/o/images%2F1759059146357?alt=media&token=1aa60666-9c1f-48d3-9a39-e44c98efa126)](https://github.com/msdio/stackticon)

**AI/ML**

[![stackticon](https://firebasestorage.googleapis.com/v0/b/stackticon-81399.appspot.com/o/images%2F1759059214584?alt=media&token=ebec7f35-2462-4a8f-9410-e7998290b225)](https://github.com/msdio/stackticon)

**DevOps & Monitoring**

[![stackticon](https://firebasestorage.googleapis.com/v0/b/stackticon-81399.appspot.com/o/images%2F1759059252027?alt=media&token=b626ca73-14ba-44f3-915f-ec7854136c69)](https://github.com/msdio/stackticon)

- **Backend Framework**: Spring Boot (WebFlux - Reactive)
- **LLM**: Google Gemini API
- **State Management**: Redis (Reactive)
- **Database**: MongoDB, Elasticsearch
- **Logging**: Elasticsearch
- **Embedding**: Python FastAPI ì„œë¹„ìŠ¤

------

### ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ (ChatBot)

**ì „ì²´ êµ¬ì¡°ë„**

![image-20260118183341793](../images/2025-09-28-ìœ ë ˆì¹´ ì¢…í•©í”„ë¡œì íŠ¸/image-20260118183341793-1768728824882-1.png)

**ë ˆì´ì–´ êµ¬ì¡°**

```
Controller Layer
    â†“
Dispatcher Layer (State Management)
    â†“
Handler Layer (State-specific Logic)
    â†“
Service Layer (Business Logic)
    â†“
Repository Layer (Data Access)
```

------

### ê¸°ìˆ ì  íŠ¹ì§•

**1. Reactive Programming**

**WebFlux ê¸°ë°˜ ë¹„ë™ê¸° ì²˜ë¦¬**:

```
Flux: ë‹¤ì¤‘ ì‘ë‹µ ìŠ¤íŠ¸ë¦¬ë°
Mono: ë‹¨ì¼ ë¹„ë™ê¸° ì‘ì—…
ë…¼ë¸”ë¡œí‚¹ I/Oë¡œ ë†’ì€ ë™ì‹œì„± ì²˜ë¦¬
```

**ì˜ˆì‹œ**:

```java
return chatBotService.classifyUserIntent(message, history)
    .flatMapMany(result -> {
        Mono<ChatResponseDto> waitMessage = buildWaitMessage(result);
        return waitMessage.concatWith(handleGeneralTopic(...));
    });
```

**2. ì „ëµ íŒ¨í„´ (Strategy Pattern)**

**í”„ë¡¬í”„íŠ¸ ì „ëµ**:

```
í† í”½ë³„ ë…ë¦½ì ì¸ í”„ë¡¬í”„íŠ¸ ìƒì„± ë¡œì§
í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡°
Spring ì˜ì¡´ì„± ì£¼ì…ì„ í†µí•œ ìë™ ë“±ë¡
```

**3. ìƒíƒœ íŒ¨í„´ (State Pattern)**

**Handler ê¸°ë°˜ ìƒíƒœ ê´€ë¦¬**:

```
ìƒíƒœë³„ ë…ë¦½ì ì¸ ì²˜ë¦¬ ë¡œì§
ìƒíƒœ ì „í™˜ ëª…í™•ì„±
Redisë¥¼ í†µí•œ ìƒíƒœ ì˜ì†ì„±
```

**4. íŒ©í† ë¦¬ íŒ¨í„´ (Factory Pattern)**

**PromptStrategyFactory**:

```
í† í”½ë³„ ì „ëµ ìë™ ë§¤í•‘
ëŸ°íƒ€ì„ ì „ëµ ì„ íƒ
EnumMapì„ í†µí•œ O(1) ì¡°íšŒ
```

**5. í”„ë¡œì„¸ì„œ íŒ¨í„´**

**Cross-cutting Concerns ì²˜ë¦¬**: ê´€ì‹¬ì‚¬ ë¶„ë¦¬ë¡œ í•µì‹¬ ë¡œì§ ë‹¨ìˆœí™”

```
ForbiddenWordProcessor: ê¸ˆì¹™ì–´ í•„í„°ë§
ChatLogProcessor: ë¡œê¹… ë° ë°ì´í„° ì €ì¥
```

**6. ì„±ëŠ¥ ìµœì í™”**

**ë¹„ë™ê¸° ë³‘ë ¬ ì²˜ë¦¬**: ì—¬ëŸ¬ ë¡œê¹… ì‘ì—…ì„ ë³‘ë ¬ë¡œ ì²˜ë¦¬ -> ì‘ë‹µ ì§€ì—° ìµœì†Œí™”

```java
return Mono.when(
    chatLogProcessor.saveRecentLog(...),
    chatLogProcessor.savePermanentLog(...),
    chatLogProcessor.saveEmbeddingIfNeeded(...),
    chatLogProcessor.saveElasticsearchLog(...)
).thenReturn(response);
```

------

### í•µì‹¬ ì»´í¬ë„ŒíŠ¸

{: .important}

**ChatBotController**

**ì—­í• **: REST API ì—”ë“œí¬ì¸íŠ¸ ì œê³µ ë° ì¸ì¦ ì²˜ë¦¬

```java
@RestController
@RequestMapping("/api/chat")
public class ChatBotController {
    @PostMapping(produces = MediaType.APPLICATION_NDJSON_VALUE)
    public Flux<ChatResponseDto> chat(
        @AuthenticationPrincipal CustomUserDetails userDetails, 
        @RequestBody ChatRequestDto requestDto
    ) {
        return chatStateDispatcher.dispatch(userDetails.getUserId(), requestDto);
    }
}
```

- `APPLICATION_NDJSON_VALUE`: Server-Sent Eventsë¥¼ í†µí•œ ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
- Spring Securityë¥¼ í†µí•œ ì‚¬ìš©ì ì¸ì¦
- Reactive Streams (`Flux`)ë¥¼ ì‚¬ìš©í•œ ë¹„ë™ê¸° ì²˜ë¦¬

------

{: .important}

**ChatStateDispatcher**

**ì—­í• **: ì‚¬ìš©ì ìš”ì²­ì„ í˜„ì¬ ìƒíƒœì— ë§ëŠ” Handlerë¡œ ë¼ìš°íŒ…

**2.1 Command ì²˜ë¦¬**

```java
public Flux<ChatResponseDto> dispatch(String userId, ChatRequestDto requestDto) {
    ChatCommand command = requestDto.getCommand();
    
    if (command.equals(ChatCommand.START_ANALYSIS)) {
        return chatStateService.setState(sessionId, ChatState.AWAITING_PERSONAL_ANALYSIS_START)
                .thenMany(dispatchByCurrentState(userId, requestDto));
    }
    
    if (command.equals(ChatCommand.CANCEL)) {
        return chatStateService.setState(sessionId, ChatState.IDLE)
                .thenReturn(ChatResponseDto.ofInfoReply(...)).flux();
    }
    
    return dispatchByCurrentState(userId, requestDto);
}
```

**2.2 ê¸ˆì¹™ì–´ í•„í„°ë§**

```java
private Flux<ChatResponseDto> dispatchByCurrentState(String userId, ChatRequestDto requestDto) {
    // ê¸ˆì¹™ì–´ í•„í„°ë§
    Flux<ChatResponseDto> filtered = forbiddenWordProcessor.filter(requestDto);
    if (!filtered.equals(Flux.empty())) {
        return filtered;
    }
    // ... ìƒíƒœ ê¸°ë°˜ ë¼ìš°íŒ…
}
```

**2.3 ìƒíƒœ ê¸°ë°˜ Handler ë¼ìš°íŒ…**

```java
return chatStateService.getState(requestDto.getSessionId())
    .flatMapMany(state -> {
        ChatStateHandler handler = handlerMap.getOrDefault(state, defaultHandler);
        return handler.handle(userId, requestDto);
    })
    .flatMap(response -> {
        // ë¡œê¹… ë° í›„ì²˜ë¦¬
        if (requestDto.getCommand() == ChatCommand.CHAT && 
            response.getType() != ChatResponseType.WAITING) {
            return Mono.when(
                chatLogProcessor.saveRecentLog(userId, requestDto, response),
                chatLogProcessor.savePermanentLog(userId, requestDto, response),
                chatLogProcessor.saveEmbeddingIfNeeded(requestDto.getMessage()),
                chatLogProcessor.saveElasticsearchLog(...)
            ).thenReturn(response);
        }
        return Mono.just(response);
    });
```

**Handler ë§µ ì´ˆê¸°í™”**:

```java
@PostConstruct
public void init() {
    for (ChatStateHandler handler : handlers) {
        handlerMap.put(handler.getState(), handler);
    }
}
```

------

{: .important}

**ChatStateHandler ì¸í„°í˜ì´ìŠ¤**

**ì—­í• **: ìƒíƒœë³„ ì²˜ë¦¬ ë¡œì§ì„ ìº¡ìŠí™”í•˜ëŠ” ì „ëµ íŒ¨í„´

```java
public interface ChatStateHandler {
    ChatState getState();
    Flux<ChatResponseDto> handle(String userId, ChatRequestDto requestDto);
}
```

**êµ¬í˜„ì²´**:

- `IdleHandler`: ê¸°ë³¸ ëŒ€í™” ìƒíƒœ ì²˜ë¦¬
- `PersonalAnalysisHandler`: ê°œì¸ ì„±í–¥ ë¶„ì„ ëª¨ë“œ
- `RecommendationHandler`: ìš”ê¸ˆì œ ì¶”ì²œ ëª¨ë“œ

------

{: .important}

**IdleHandler**

**ì—­í• **: ê¸°ë³¸ ëŒ€í™” ìƒíƒœì—ì„œ ì‚¬ìš©ì ì˜ë„ë¥¼ ë¶„ë¥˜í•˜ê³  ì ì ˆí•œ ì‘ë‹µ ìƒì„±

**ì²˜ë¦¬ íë¦„**:

```java
@Override
public Flux<ChatResponseDto> handle(String userId, ChatRequestDto requestDto) {
    // 1. ìµœê·¼ ëŒ€í™” ê¸°ë¡ ì¡°íšŒ
    String recentChatHistory = JsonUtil.toJson(
        chatLogService.getRecentChatHistory(userId, requestDto.getSessionId())
    );

    // 2. ì‚¬ìš©ì ì˜ë„ ë¶„ë¥˜
    return chatBotService.classifyUserIntent(requestDto.getMessage(), recentChatHistory)
        .flatMapMany(result -> {
            // 3. ëŒ€ê¸° ë©”ì‹œì§€ ìƒì„±
            Mono<ChatResponseDto> waitMessage = buildWaitMessage(result);
            
            // 4. í† í”½ë³„ ì²˜ë¦¬
            if (result.getTopic() == Topic.ALL_PLAN_LIST) {
                return waitMessage.concatWith(handleAllPlanTopic(requestDto));
            }
            return waitMessage.concatWith(
                handleGeneralTopic(result.getTopic(), requestDto, recentChatHistory)
            );
        });
}
```

**í† í”½ë³„ í”„ë¡¬í”„íŠ¸ ìƒì„±**:

```java
private String generatePromptByTopic(Topic topic) {
    PromptStrategy strategy = promptStrategyFactory.getStrategy(topic);
    return switch (topic) {
        case PLAN_DETAIL, PLAN_LIST, COMPARE_PLAN, RECOMMENDATION_PLAN -> {
            List<PlanDto> plans = planProvider.getPlans();
            List<PlanForLLMDto> planForLLM = PlanLLMConverter.convertToLLMDto(plans);
            String plansJson = JsonUtil.toJson(planForLLM);
            yield PromptStrategyInvoker.invokeSingleArgStrategy(strategy, plansJson);
        }
        default -> PromptStrategyInvoker.invokeNoArgsStrategy(strategy);
    };
}
```

------

{: .important}

**PersonalAnalysisHandler**

**ì—­í• **: ì‚¬ìš©ì ì„±í–¥ ë¶„ì„ì„ ìœ„í•œ ë‹¨ê³„ë³„ ì§ˆë¬¸ ì²˜ë¦¬

**ì£¼ìš” ê¸°ëŠ¥**:

**5.1 ë¶„ì„ ë‹¨ê³„ ê´€ë¦¬**

```java
private Flux<ChatResponseDto> processAnalysisStep(
    String sessionId, String userId, String message, UserChatAnalysis analysis
) {
    int currentStep = analysis.getCurrentStep();
    int totalSteps = questionProvider.total();
    String questionText = questionProvider.getQuestion(currentStep);
    
    // ì‘ë‹µ ê²€ì¦
    String validationPrompt = PromptTemplateProvider.buildPersonalValidationPrompt(questionText);
    return chatBotService.validateAnalysisAnswer(validationPrompt, message)
        .flatMapMany(validationResult -> 
            processValidationResult(sessionId, userId, message, currentStep, totalSteps, validationResult)
        );
}
```

**5.2 ì‘ë‹µ ê²€ì¦ ë° í”¼ë“œë°±**

```java
private Flux<ChatResponseDto> handleInvalidAnswer(
    String sessionId, int currentStep, ChatbotRawResponseDto validationResult
) {
    String questionText = questionProvider.getQuestion(currentStep);
    
    ChatResponseDto feedback = ChatResponseDto.ofFeedBack(validationResult.getReply());
    ChatResponseDto retryQuestion = ChatResponseDto.ofAnalysisReply(questionText);
    
    return Flux.concat(
        Mono.just(feedback),
        Mono.delay(Duration.ofSeconds(1)).thenReturn(retryQuestion)
    );
}
```

**5.3 ë¶„ì„ ì™„ë£Œ í›„ ìµœì¢… ì¶”ì²œ**

```java
private Flux<ChatResponseDto> handleAnalysisCompletion(
    String sessionId, String userId, ChatbotRawResponseDto validationResult
) {
    UserDto userDto = userService.findById(userId);
    return chatStateService.setState(sessionId, ChatState.IDLE)
        .thenMany(
            Flux.concat(
                Flux.just(ChatResponseDto.ofWaitingReply("ë¶„ì„ ì¤‘...")),
                Mono.fromCallable(() -> chatLogService.getAnalysis(sessionId))
                    .flatMapMany(analysisResult -> 
                        processAnalysisResult(userDto, validationResult, analysisResult)
                    )
            )
        );
}
```

------

### ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œ

```java
public enum ChatState {
    IDLE,                                    // ê¸°ë³¸ ëŒ€í™” ìƒíƒœ
    AWAITING_LINE_SELECTION,                 // íšŒì„  ì„ íƒ ëŒ€ê¸°
    AWAITING_PERSONAL_ANALYSIS_START,        // ì„±í–¥ ë¶„ì„ ì‹œì‘ ëŒ€ê¸°
    PERSONAL_ANALYSIS,                       // ì„±í–¥ ë¶„ì„ ì§„í–‰ ì¤‘
    AWAITING_ADDITIONAL_FEEDBACK,            // ì¶”ê°€ í”¼ë“œë°± ëŒ€ê¸°
    RECOMMENDATION_START                     // ì¶”ì²œ ëª¨ë“œ ì‹œì‘
}
```

{: .warning}

**ChatStateService êµ¬í˜„**

**Redis ê¸°ë°˜ ìƒíƒœ ì €ì¥**:

```java
@Service
public class ChatStateServiceImpl implements ChatStateService {
    private final ReactiveRedisTemplate<String, UserChatState> redisTemplate;
    
    @Override
    public Mono<ChatState> getState(String sessionId) {
        return redisTemplate.opsForValue()
            .get(redisKey(sessionId))
            .map(UserChatState::getState)
            .defaultIfEmpty(ChatState.IDLE);
    }
    
    @Override
    public Mono<ChatState> setState(String sessionId, ChatState state) {
        UserChatState userState = new UserChatState(sessionId, state);
        return redisTemplate.opsForValue()
            .set(redisKey(sessionId), userState)
            .thenReturn(state);
    }
}
```

**íŠ¹ì§•**:

- Reactive Redisë¥¼ ì‚¬ìš©í•œ ë¹„ë™ê¸° ìƒíƒœ ê´€ë¦¬
- ì„¸ì…˜ë³„ ìƒíƒœ ê²©ë¦¬
- ê¸°ë³¸ê°’ìœ¼ë¡œ `IDLE` ìƒíƒœ ë°˜í™˜

------

### í† í”½ ë¶„ë¥˜ ì‹œìŠ¤í…œ

**Topic Enum**

```java
public enum Topic {
    INFO,                    // ì•± ì‚¬ìš© ë°©ë²• ë¬¸ì˜
    PLAN_DETAIL,            // íŠ¹ì • ìš”ê¸ˆì œ ìƒì„¸ ì •ë³´
    RECOMMENDATION_PLAN,    // ì¡°ê±´ ì—†ëŠ” ìš”ê¸ˆì œ ì¶”ì²œ
    PLAN_LIST,              // ì¡°ê±´ ê¸°ë°˜ ìš”ê¸ˆì œ ëª©ë¡
    ALL_PLAN_LIST,          // ì „ì²´ ìš”ê¸ˆì œ ëª©ë¡
    COMPARE_PLAN,           // ìš”ê¸ˆì œ ê°„ ë¹„êµ
    COMPARE_WITH_MY_PLAN,   // ë‚´ ìš”ê¸ˆì œì™€ ë¹„êµ
    MY_USAGE_INFORMATION,   // ì‚¬ìš©ëŸ‰ ì •ë³´ ì¡°íšŒ
    ETC                     // ê¸°íƒ€ ëŒ€í™”
}
```

**ì˜ë„ ë¶„ë¥˜ í”„ë¡œì„¸ìŠ¤**

```java
@Override
public Mono<ClassifiedTopicResult> classifyUserIntent(
    String message, String recentHistory
) {
    Map<String, Object> requestBody = buildTopicClassifyBody(message, recentHistory);
    
    return sendChatRequest(requestBody)
        .map(GeminiResponseUtils::extractTextFromResponse)
        .map(GeminiResponseParser::toTopicResult)
        .onErrorResume(e -> 
            Mono.just(new ClassifiedTopicResult(Topic.ETC, "ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”"))
        );
}
```

**íŠ¹ì§•**:

- ìµœê·¼ ëŒ€í™” ê¸°ë¡ì„ ì»¨í…ìŠ¤íŠ¸ë¡œ í™œìš©
- ì—ëŸ¬ ë°œìƒ ì‹œ ê¸°ë³¸ê°’(`ETC`) ë°˜í™˜ìœ¼ë¡œ ì•ˆì •ì„± í™•ë³´
- Gemini APIë¥¼ í†µí•œ ìì—°ì–´ ê¸°ë°˜ ë¶„ë¥˜

------

### í”„ë¡¬í”„íŠ¸ ì „ëµ íŒ¨í„´

**PromptStrategy ì¸í„°í˜ì´ìŠ¤**

```java
public interface PromptStrategy {
    Optional<Topic> support();
}
```

**ì „ëµ êµ¬í˜„ì²´ ê³„ì¸µ êµ¬ì¡°**

```
PromptStrategy (Interface)
    â”œâ”€â”€ NoArgsPromptStrategy (ì¸ì ì—†ìŒ)
    â”‚   â”œâ”€â”€ EtcPromptStrategy
    â”‚   â”œâ”€â”€ ServiceInfoPromptStrategy
    â”‚   â””â”€â”€ AllPlanPromptStrategy
    â”‚
    â”œâ”€â”€ SingleArgsPromptStrategy (ë‹¨ì¼ ì¸ì)
    â”‚   â”œâ”€â”€ PlanDetailPromptStrategy
    â”‚   â”œâ”€â”€ FilteredPlanPromptStrategy
    â”‚   â”œâ”€â”€ RecommendPromptStrategy
    â”‚   â””â”€â”€ ComparePlanPromptStrategy
    â”‚
    â””â”€â”€ DoubleArgsPromptStrategy (ë³µìˆ˜ ì¸ì)
        â””â”€â”€ CompareWithMyPlanPromptStrategy
```

**PromptStrategyFactory**

**ì—­í• **: í† í”½ë³„ ì ì ˆí•œ ì „ëµ ì„ íƒ

```java
@Component
public class PromptStrategyFactory {
    private final List<PromptStrategy> strategies;
    private final Map<Topic, PromptStrategy> strategyMap = new EnumMap<>(Topic.class);
    
    @PostConstruct
    public void init() {
        for (PromptStrategy strategy : strategies) {
            strategy.support().ifPresent(topic -> strategyMap.put(topic, strategy));
        }
    }
    
    public PromptStrategy getStrategy(Topic topic) {
        PromptStrategy strategy = strategyMap.get(topic);
        if (strategy == null) {
            throw new IllegalArgumentException("í•´ë‹¹ í† í”½ì„ ì§€ì›í•˜ëŠ” í”„ë¡¬í”„íŠ¸ ì „ëµì´ ì—†ìŠµë‹ˆë‹¤: " + topic);
        }
        return strategy;
    }
}
```

**íŠ¹ì§•**:

- Springì˜ ì˜ì¡´ì„± ì£¼ì…ì„ í†µí•œ ì „ëµ ìë™ ë“±ë¡
- EnumMapì„ ì‚¬ìš©í•œ O(1) ì¡°íšŒ ì„±ëŠ¥
- í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡° (ìƒˆë¡œìš´ ì „ëµ ì¶”ê°€ ìš©ì´)

------

### LLM í†µí•© (Google Gemini)

**GeminiService**

**ì—­í• **: Google Gemini APIì™€ì˜ í†µì‹  ë‹´ë‹¹

```java
@Service
public class GeminiService implements ChatBotService {
    @Value("${gemini.api.key}")
    private String apiKey;
    
    private final WebClient webClient;
    private final String geminiFullPath;
    
    // 1. ì¼ë°˜ ëŒ€í™” ì‘ë‹µ ìƒì„±
    @Override
    public Mono<ChatbotRawResponseDto> generateChatReply(
        String prompt, String message, String recentChatHistory
    ) {
        Map<String, Object> requestBody = buildChatBody(prompt, message, recentChatHistory);
        return sendChatRequest(requestBody)
            .map(GeminiResponseUtils::extractTextFromResponse)
            .map(GeminiResponseParser::toChatbotResponse);
    }
    
    // 2. ì˜ë„ ë¶„ë¥˜
    @Override
    public Mono<ClassifiedTopicResult> classifyUserIntent(
        String message, String recentHistory
    ) {
        Map<String, Object> requestBody = buildTopicClassifyBody(message, recentHistory);
        return sendChatRequest(requestBody)
            .map(GeminiResponseUtils::extractTextFromResponse)
            .map(GeminiResponseParser::toTopicResult)
            .onErrorResume(e -> 
                Mono.just(new ClassifiedTopicResult(Topic.ETC, "ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”"))
            );
    }
    
    // 3. ë¶„ì„ ì‘ë‹µ ê²€ì¦
    @Override
    public Mono<ChatbotRawResponseDto> validateAnalysisAnswer(
        String prompt, String message
    ) {
        Map<String, Object> requestBody = buildValidAnswerBody(prompt, message);
        return sendChatRequest(requestBody)
            .map(GeminiResponseUtils::extractTextFromResponse)
            .map(GeminiResponseParser::toChatbotResponse);
    }
    
    // 4. ìµœì¢… ì¶”ì²œ ìƒì„±
    @Override
    public Mono<ChatbotRawResponseDto> generateFinalRecommendation(String prompt) {
        Map<String, Object> requestBody = buildRecommendByAnalysisBody(prompt);
        return sendChatRequest(requestBody)
            .map(GeminiResponseUtils::extractTextFromResponse)
            .map(GeminiResponseParser::toChatbotResponse);
    }
    
    private Mono<Map> sendChatRequest(Map<String, Object> requestBody) {
        return webClient.post()
            .uri(uriBuilder -> uriBuilder
                .path(geminiFullPath)
                .queryParam("key", apiKey)
                .build())
            .bodyValue(requestBody)
            .retrieve()
            .bodyToMono(Map.class);
    }
}
```

**ì£¼ìš” ë©”ì„œë“œ**:

1. `generateChatReply`: ì¼ë°˜ ëŒ€í™” ì‘ë‹µ ìƒì„±
2. `classifyUserIntent`: ì‚¬ìš©ì ì˜ë„ ë¶„ë¥˜
3. `validateAnalysisAnswer`: ë¶„ì„ ì§ˆë¬¸ ì‘ë‹µ ê²€ì¦
4. `generateFinalRecommendation`: ìµœì¢… ì¶”ì²œ ìƒì„±

------

### ë°ì´í„° íë¦„

**ì¼ë°˜ ëŒ€í™” íë¦„**

```
1. ì‚¬ìš©ì ë©”ì‹œì§€ ì…ë ¥
   â†“
2. ChatBotController.chat()
   â†“
3. ChatStateDispatcher.dispatch()
   â”œâ”€ ê¸ˆì¹™ì–´ í•„í„°ë§
   â”œâ”€ í˜„ì¬ ìƒíƒœ ì¡°íšŒ (Redis)
   â””â”€ ì ì ˆí•œ Handler ì„ íƒ
   â†“
4. IdleHandler.handle()
   â”œâ”€ ìµœê·¼ ëŒ€í™” ê¸°ë¡ ì¡°íšŒ
   â”œâ”€ ì˜ë„ ë¶„ë¥˜ (Gemini API)
   â”œâ”€ í† í”½ë³„ í”„ë¡¬í”„íŠ¸ ìƒì„±
   â””â”€ ì‘ë‹µ ìƒì„± (Gemini API)
   â†“
5. ChatLogProcessor
   â”œâ”€ ìµœê·¼ ëŒ€í™” ë¡œê·¸ ì €ì¥ (Redis)
   â”œâ”€ ì˜êµ¬ ëŒ€í™” ë¡œê·¸ ì €ì¥ (MongoDB)
   â”œâ”€ Embedding ìƒì„± ë° ì €ì¥ (Elasticsearch)
   â””â”€ ë¶„ì„ ë¡œê·¸ ì €ì¥ (Elasticsearch)
   â†“
6. í´ë¼ì´ì–¸íŠ¸ë¡œ ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µ
```

**ê°œì¸ ì„±í–¥ ë¶„ì„ íë¦„**

```
1. START_ANALYSIS ëª…ë ¹
   â†“
2. ìƒíƒœ ë³€ê²½: AWAITING_PERSONAL_ANALYSIS_START â†’ PERSONAL_ANALYSIS
   â†“
3. PersonalAnalysisHandler.handle()
   â”œâ”€ í˜„ì¬ ë‹¨ê³„ í™•ì¸
   â”œâ”€ ì§ˆë¬¸ ì œê³µ
   â””â”€ ì‚¬ìš©ì ì‘ë‹µ ëŒ€ê¸°
   â†“
4. ì‚¬ìš©ì ì‘ë‹µ ì…ë ¥
   â†“
5. ì‘ë‹µ ê²€ì¦ (Gemini API)
   â”œâ”€ ìœ íš¨í•œ ì‘ë‹µ â†’ ë‹¤ìŒ ì§ˆë¬¸ ë˜ëŠ” ì™„ë£Œ
   â””â”€ ë¬´íš¨í•œ ì‘ë‹µ â†’ í”¼ë“œë°± ë° ì¬ì§ˆë¬¸
   â†“
6. ëª¨ë“  ì§ˆë¬¸ ì™„ë£Œ ì‹œ
   â”œâ”€ ë¶„ì„ ê²°ê³¼ ìˆ˜ì§‘
   â”œâ”€ ìµœì¢… ì¶”ì²œ ìƒì„± (Gemini API)
   â””â”€ ìš”ê¸ˆì œ ì¹´ë“œì™€ í•¨ê»˜ ì‘ë‹µ
```

------

### ë‹´ë‹¹ ì—­í• 

ì´ë²ˆ í”„ë¡œì íŠ¸ì—ì„œ ì €ëŠ” **AI ì±—ë´‡ ê¸°ë°˜ ìš”ê¸ˆì œ ì¶”ì²œ ì„œë¹„ìŠ¤ì˜ ë¶„ì„ í™˜ê²½**ì„ ë‹´ë‹¹í–ˆìŠµë‹ˆë‹¤.

{: .q-left}

> ì±—ë´‡ ë¶„ì„ ë¡œê·¸ ëŒ€ì‹œë³´ë“œ êµ¬ì„±

ì±—ë´‡ì´ ì‹¤ì œë¡œ ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•´ **ì›ë³¸ ëŒ€í™” ì „ì²´ë¥¼ ì˜êµ¬ ë³´ê´€í•˜ëŠ”** MongoDBì™€ëŠ” ë‹¬ë¦¬ ë¶„ì„ ìš©ë„ë¡œ**Elasticsearchì™€ Kibana**ë¥¼ í™œìš©í•´ ë¶„ì„ì— í•„ìš”í•œ í•„ë“œë§Œ ë¹„ì •ê·œí™”í•´ì„œ **ëŒ€ì‹œë³´ë“œ**ë¥¼ êµ¬ì„±í–ˆìŠµë‹ˆë‹¤.

ì´ êµ¬ì¡°ëŠ” ES ì¸ë±ìŠ¤ê°€ ê¹¨ì ¸ë„ ëŒ€í™” ì›ë³¸ì€ ì•ˆì „í•˜ê³  ë¶„ì„ ë¶€í•˜ê°€ ì»¤ì ¸ë„ ì„œë¹„ìŠ¤ DB(MongoDB)ì— ì˜í–¥ì€ ì ê¸° ë•Œë¬¸ì— ì¥ì• /í™•ì¥ ê´€ì ì—ì„œë„ ì•ˆì „í•˜ì˜€ìŠµë‹ˆë‹¤.

**ëŒ€ì‹œë³´ë“œ êµ¬ì„±:**

- ì–´ë–¤ ì˜ë„ë¡œ ì§ˆë¬¸ì´ ë“¤ì–´ì™”ëŠ”ì§€,
- ì‘ë‹µ ì†ë„ëŠ” ì–¼ë§ˆë‚˜ ê±¸ë ¸ëŠ”ì§€,
- ì¶”ì²œ ì§ˆë¬¸ì´ ì–¼ë§ˆë‚˜ í´ë¦­ë˜ì—ˆëŠ”ì§€,
- ì‚¬ìš©ìë³„ ëŒ€í™” íë¦„ì€ ì–´ë–»ê²Œ ì´ì–´ì¡ŒëŠ”ì§€

ì´ ëª¨ë“  ë°ì´í„°ë¥¼ ì‹œê°í™”í•´ì„œ í•œëˆˆì— í™•ì¸í•  ìˆ˜ ìˆë„ë¡ í–ˆìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ë‹¨ìˆœíˆ ì‘ë™í•˜ëŠ” ì±—ë´‡ì´ ì•„ë‹ˆë¼, **ë°ì´í„° ê¸°ë°˜ìœ¼ë¡œ ì§€ì†ì ìœ¼ë¡œ ê°œì„ í•  ìˆ˜ ìˆëŠ” ì±—ë´‡**ìœ¼ë¡œ ë°œì „ì‹œí‚¬ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

{: .q-left}

> ìŒì„± ì…ë ¥(STT) ê¸°ëŠ¥ êµ¬í˜„

**ETRIì˜ STT API**ë¥¼ í™œìš©í•˜ì—¬ ì‚¬ìš©ìê°€ í…ìŠ¤íŠ¸ ì…ë ¥ë¿ë§Œ ì•„ë‹ˆë¼ **ìŒì„±ìœ¼ë¡œ ì§ˆë¬¸**ì„ í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤. 

ì‚¬ìš©ìì˜ ë°œí™”ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜í•˜ê³ , ì´ë¥¼ ì±—ë´‡ ëŒ€í™” ë§¥ë½ì— ìì—°ìŠ¤ëŸ½ê²Œ ë°˜ì˜í•  ìˆ˜ ìˆë„ë¡ í–ˆìŠµë‹ˆë‹¤. 

ì´ë¥¼ í†µí•´ ê¸°ì¡´ì˜ í‚¤ë³´ë“œ ì…ë ¥ ìœ„ì£¼ ìƒë‹´ì—ì„œ ë²—ì–´ë‚˜ **ë©€í‹°ëª¨ë‹¬ ìƒë‹´ ê²½í—˜**ì„ ì œê³µí–ˆìŠµë‹ˆë‹¤.

{: .q-left}

> ì¶”ì²œ ì§ˆë¬¸ ì œê³µ (ì„ë² ë”© ê¸°ë°˜)

**OpenAI ì„ë² ë”© ëª¨ë¸**ê³¼ **FastAPI** ì„œë²„ë¥¼ ì—°ë™í•˜ì—¬, ì‚¬ìš©ìê°€ ì…ë ¥í•œ ì§ˆë¬¸ì„ ë²¡í„°í™”í•˜ê³  ì´ë¯¸ Elasticsearchì— ì €ì¥ëœ ì§ˆë¬¸ ë²¡í„°ì™€ **ìœ ì‚¬ë„ ê²€ìƒ‰**ì„ ìˆ˜í–‰í–ˆìŠµë‹ˆë‹¤.

ê·¸ ê²°ê³¼, ì‚¬ìš©ìëŠ” ë‹¨ìˆœíˆ ë‹µë³€ë§Œ ë°›ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ë§¥ë½ì— ë§ëŠ” **ì¶”ì²œ ì§ˆë¬¸ ë¦¬ìŠ¤íŠ¸**ë¥¼ ì¶”ê°€ë¡œ í™•ì¸í•  ìˆ˜ ìˆì–´, ë” ê¹Šì´ ìˆëŠ” ëŒ€í™”ë¥¼ ì´ì–´ê°ˆ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

ì¶”ì²œ ì§ˆë¬¸ ê¸°ëŠ¥ì€ í‚¤ì›Œë“œ ë§¤ì¹­ì´ ì•„ë‹Œ ì˜ë¯¸ ê¸°ë°˜ ìœ ì‚¬ë„ ë¬¸ì œë¡œ ì •ì˜í•˜ê³ , OpenAI ì„ë² ë”© ëª¨ë¸ì„ í™œìš©í•´ ì§ˆë¬¸ì„ ë²¡í„°í™”í•œ ë’¤ Elasticsearchì˜ ë²¡í„° ê²€ìƒ‰ ê¸°ëŠ¥ìœ¼ë¡œ ì—°ê´€ ì§ˆë¬¸ì„ ë„ì¶œí–ˆìŠµë‹ˆë‹¤.
ì„ë² ë”© ì²˜ë¦¬ëŠ” FastAPI ê¸°ë°˜ì˜ ë³„ë„ ì„œë¹„ìŠ¤ë¡œ ë¶„ë¦¬í•´ Spring ë©”ì¸ ì„œë¹„ìŠ¤ì™€ì˜ ê²°í•©ë„ë¥¼ ë‚®ì¶”ê³  ì•ˆì •ì„±ì„ í™•ë³´í–ˆìŠµë‹ˆë‹¤.
