---
layout: post
title: GC알고리즘
description: GC알고리즘에 대해 알아보자
image: '/images/2025-08-12-GC알고리즘/java-garbage-collector-types.png'
tags: [Java,Interview]
tags_color: '#87CEFA'
---

## **가비지 컬렉션 알고리즘 종류**

JVM이 메모리를 자동으로 관리해주는 것은 개발자의 입장에서 상당한 메리트입니다. 
하지만 문제는 GC를 수행하기 위해 Stop The World가 발생되고 이 때문에 애플리케이션이 중지되는 문제점이 발생하게 됩니다.

또한 자바가 발전됨에 따라 Heap의 사이즈가 커지면서 애플리케이션의 지연(Suspend) 현상이 두드러지게 되었고, 이를 최적화 위해 다양한 Garbage Collection(가비지 컬렉션) 알고리즘이 개발되었습니다.

여기서 알아두어야 할 것은 소개할 GC 알고리즘은 모두 설정을 통해 Java에 적용할수 있다는 점입니다.
즉, 상황에 따라 필요한 GC 방식을 설정해서 사용할 수 있습니다. 

------

### **Serial GC**

JDK에 도입된 최초의 가바지 컬렉터이며, 단일 스레드로 동작하는 가장 단순한 형태입니다. 작은 힙 메모리와 단일 CPU 환경에 적합하며 Stop-The-World 시간이 가장 길게 발생합니다.

- Minor GC 에는 Mark-Sweep을 사용하고, Major GC에는 Mark-Sweep-Compact를 사용.
-  보통 실무에서 사용하는 경우는 없다 (디바이스 성능이 안좋아서 CPU 코어가 1개인 경우에만 사용) 

![image-20250813010830497](../images/2025-08-12-GC알고리즘/image-20250813010830497-1755014915824-3-1755014918600-5.png)

{: .important}

Serial GC 실행 명령어

자바 프로그램을 실행할때 -XX:+UseSerialGC GC 옵션을 지정하여 해당 가비지 컬렉션 알고리즘으로 힙 메모리를 관리하도록 실행할 수 있습니다.

```bash
java -XX:+UseSerialGC -jar Application.java
```

------

### **Parallel GC** 

Java 5부터 8까지 **default** 가비지 컬렉터로 사용되었으며, Serial GC와 달리 Young 영역의 GC를 멀티 스레드로 수행합니다. 높은 처리량에 초점을 두기 때문에 Throughput GC라고도 불립니다.

**Parallel Old GC**는 Parallel GC의 향상된 버전으로, Old 영역에서도 멀티 스레드를 활용하여 GC를 수행합니다.

**CMS(Concurrent Mark-Sweep) GC**는 Java 5부터 8까지 사용된 가비지 컬렉터로, 애플리케이션 스레드와 병렬로 실행되어 Stop-The-World 시간을 최소화하도록 설계되었습니다. 하지만 메모리와 CPU 사용량이 많고, 메모리 압축을 수행하지 않아 메모리 단편화 문제가 있습니다. Java 9부터 deprecated 되고, Java 14에서 완전히 제거되었습니다.

**G1(Garbage First) GC**는 Java 9부터 **default** 가비지 컬렉터이며, 기존의 GC 방식과 달리 힙을 여러 개의 region으로 나누어 논리적으로 Young, Old 영역을 구분합니다. 처리량과 Stop-The-World 시간 사이의 균형을 유지하며 32GB보다 작은 힙 메모리를 사용할 때 가장 효과적입니다. GC 대상이 많은 region을 먼저 회수하기 때문에 garbage first라는 이름이 붙었습니다.

**ZGC**는 Java 11부터 도입된 가비지 컬렉터로, 10ms 이하의 Stop-The-World 시간과 대용량 힙을 처리할 수 있도록 설계되었습니다.

**Shenandoah GC**는 Red Hat에서 개발한 가비지 컬렉터로, Java 12부터 도입되었습니다. G1 GC와 마찬가지로 힙을 여러 개의 region으로 나누어 처리하며, ZGC처럼 저지연 Stop-The-World와 대용량 힙 처리를 목표로 합니다.

**Epsilon GC**는 Java 11부터 도입되었으며 GC 기능이 없는 실험용 가비지 컬렉터입니다. 애플리케이션 성능 테스트에서 GC 영향을 분리하거나 GC 오버헤드 없이 메모리 한계를 테스트할 때 사용되지만, 프로덕션 환경에는 적합하지 않습니다.

## G1 GC에서 Humongous 객체란 무엇이며 어떻게 처리되나요?

**Humongous 객체**는 region 크기의 50% 이상을 차지하는 큰 객체를 의미합니다. Humongous 객체는 크기에 따라 하나 또는 여러 개의 연속된 region을 차지할 수 있고, region 내 잉여 공간은 다른 객체에 할당되지 않아 메모리 단편화가 발생할 수 있습니다. 또한, Young 영역을 거치지 않고 바로 Old 영역에 할당되기 때문에 Full GC가 발생할 가능성이 높아집니다. 이 문제를 해결하려면 `-XX:G1HeapRegionSize` 옵션을 사용하여 region 크기를 조정하거나, 큰 객체를 작은 객체로 분할하여 처리해 볼 수 있습니다.

## 2vCPU, 1GB 메모리를 가진 Linux 서버에 JDK 17을 설치하면 어떤 가비지 컬렉터가 사용될까요?

JDK 9부터 G1 GC가 default 가비지 컬렉터이지만, 서버 스펙에 따라 자동으로 결정됩니다.

OpenJDK에서는 **CPU 코어 수가 2개 이상이고 메모리가 2GB 이상일 경우** 서버를 **Server-Class Machine**으로 인식합니다. Server-Class Machine이라면 가비지 컬렉터로 G1 GC가 선택되지만, 이 서버는 조건을 충족하지 않기 때문에 Serial GC가 선택됩니다. G1 GC를 사용하려면 서버를 스케일업하거나 `-XX:+UseG1GC` 옵션을 명시적으로 설정해야 합니다.
